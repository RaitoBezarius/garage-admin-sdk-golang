/*
Garage Administration API v0+garage-v0.9.0

Administrate your Garage cluster programatically, including status, layout, keys, buckets, and maintainance tasks.  *Disclaimer: The API is not stable yet, hence its v0 tag. The API can change at any time, and changes can include breaking backward compatibility. Read the changelog and upgrade your scripts before upgrading. Additionnaly, this specification is very early stage and can contain bugs, especially on error return codes/types that are not tested yet. Do not expect a well finished and polished product!* 

API version: v0.9.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package garage

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// BucketApiService BucketApi service
type BucketApiService service

type ApiAllowBucketKeyRequest struct {
	ctx context.Context
	ApiService *BucketApiService
	allowBucketKeyRequest *AllowBucketKeyRequest
}

// Aliases to put on the new bucket 
func (r ApiAllowBucketKeyRequest) AllowBucketKeyRequest(allowBucketKeyRequest AllowBucketKeyRequest) ApiAllowBucketKeyRequest {
	r.allowBucketKeyRequest = &allowBucketKeyRequest
	return r
}

func (r ApiAllowBucketKeyRequest) Execute() (*BucketInfo, *http.Response, error) {
	return r.ApiService.AllowBucketKeyExecute(r)
}

/*
AllowBucketKey Allow key

⚠️ **DISCLAIMER**: Garage's developers are aware that this endpoint has an unconventional semantic. Be extra careful when implementing it, its behavior is not obvious.

Allows a key to do read/write/owner operations on a bucket.

Flags in permissions which have the value true will be activated. Other flags will remain unchanged (ie. they will keep their internal value).

For example, if you set read to true, the key will be allowed to read the bucket.
If you set it to false, the key will keeps its previous read permission.
If you want to disallow read for the key, check the DenyBucketKey operation.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAllowBucketKeyRequest
*/
func (a *BucketApiService) AllowBucketKey(ctx context.Context) ApiAllowBucketKeyRequest {
	return ApiAllowBucketKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BucketInfo
func (a *BucketApiService) AllowBucketKeyExecute(r ApiAllowBucketKeyRequest) (*BucketInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BucketInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketApiService.AllowBucketKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucket/allow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.allowBucketKeyRequest == nil {
		return localVarReturnValue, nil, reportError("allowBucketKeyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.allowBucketKeyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBucketRequest struct {
	ctx context.Context
	ApiService *BucketApiService
	createBucketRequest *CreateBucketRequest
}

// Aliases to put on the new bucket 
func (r ApiCreateBucketRequest) CreateBucketRequest(createBucketRequest CreateBucketRequest) ApiCreateBucketRequest {
	r.createBucketRequest = &createBucketRequest
	return r
}

func (r ApiCreateBucketRequest) Execute() (*BucketInfo, *http.Response, error) {
	return r.ApiService.CreateBucketExecute(r)
}

/*
CreateBucket Create a bucket

Creates a new bucket, either with a global alias, a local one, or no alias at all.
Technically, you can also specify both `globalAlias` and `localAlias` and that would create two aliases.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBucketRequest
*/
func (a *BucketApiService) CreateBucket(ctx context.Context) ApiCreateBucketRequest {
	return ApiCreateBucketRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BucketInfo
func (a *BucketApiService) CreateBucketExecute(r ApiCreateBucketRequest) (*BucketInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BucketInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketApiService.CreateBucket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createBucketRequest == nil {
		return localVarReturnValue, nil, reportError("createBucketRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createBucketRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBucketRequest struct {
	ctx context.Context
	ApiService *BucketApiService
	id *string
}

// The exact bucket identifier, a 32 bytes hexadecimal string
func (r ApiDeleteBucketRequest) Id(id string) ApiDeleteBucketRequest {
	r.id = &id
	return r
}

func (r ApiDeleteBucketRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteBucketExecute(r)
}

/*
DeleteBucket Delete a bucket

Delete a bucket.Deletes a storage bucket. A bucket cannot be deleted if it is not empty.

**Warning:** this will delete all aliases associated with the bucket!


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteBucketRequest
*/
func (a *BucketApiService) DeleteBucket(ctx context.Context) ApiDeleteBucketRequest {
	return ApiDeleteBucketRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BucketApiService) DeleteBucketExecute(r ApiDeleteBucketRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketApiService.DeleteBucket")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteBucketGlobalAliasRequest struct {
	ctx context.Context
	ApiService *BucketApiService
	id *string
	alias *string
}

func (r ApiDeleteBucketGlobalAliasRequest) Id(id string) ApiDeleteBucketGlobalAliasRequest {
	r.id = &id
	return r
}

func (r ApiDeleteBucketGlobalAliasRequest) Alias(alias string) ApiDeleteBucketGlobalAliasRequest {
	r.alias = &alias
	return r
}

func (r ApiDeleteBucketGlobalAliasRequest) Execute() (*BucketInfo, *http.Response, error) {
	return r.ApiService.DeleteBucketGlobalAliasExecute(r)
}

/*
DeleteBucketGlobalAlias Delete a global alias

Delete a global alias from the target bucket


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteBucketGlobalAliasRequest
*/
func (a *BucketApiService) DeleteBucketGlobalAlias(ctx context.Context) ApiDeleteBucketGlobalAliasRequest {
	return ApiDeleteBucketGlobalAliasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BucketInfo
func (a *BucketApiService) DeleteBucketGlobalAliasExecute(r ApiDeleteBucketGlobalAliasRequest) (*BucketInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BucketInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketApiService.DeleteBucketGlobalAlias")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucket/alias/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.alias == nil {
		return localVarReturnValue, nil, reportError("alias is required and must be specified")
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	localVarQueryParams.Add("alias", parameterToString(*r.alias, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBucketLocalAliasRequest struct {
	ctx context.Context
	ApiService *BucketApiService
	id *string
	accessKeyId *string
	alias *string
}

func (r ApiDeleteBucketLocalAliasRequest) Id(id string) ApiDeleteBucketLocalAliasRequest {
	r.id = &id
	return r
}

func (r ApiDeleteBucketLocalAliasRequest) AccessKeyId(accessKeyId string) ApiDeleteBucketLocalAliasRequest {
	r.accessKeyId = &accessKeyId
	return r
}

func (r ApiDeleteBucketLocalAliasRequest) Alias(alias string) ApiDeleteBucketLocalAliasRequest {
	r.alias = &alias
	return r
}

func (r ApiDeleteBucketLocalAliasRequest) Execute() (*BucketInfo, *http.Response, error) {
	return r.ApiService.DeleteBucketLocalAliasExecute(r)
}

/*
DeleteBucketLocalAlias Delete a local alias

Delete a local alias, bound to specified account, from the target bucket


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteBucketLocalAliasRequest
*/
func (a *BucketApiService) DeleteBucketLocalAlias(ctx context.Context) ApiDeleteBucketLocalAliasRequest {
	return ApiDeleteBucketLocalAliasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BucketInfo
func (a *BucketApiService) DeleteBucketLocalAliasExecute(r ApiDeleteBucketLocalAliasRequest) (*BucketInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BucketInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketApiService.DeleteBucketLocalAlias")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucket/alias/local"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.accessKeyId == nil {
		return localVarReturnValue, nil, reportError("accessKeyId is required and must be specified")
	}
	if r.alias == nil {
		return localVarReturnValue, nil, reportError("alias is required and must be specified")
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	localVarQueryParams.Add("accessKeyId", parameterToString(*r.accessKeyId, ""))
	localVarQueryParams.Add("alias", parameterToString(*r.alias, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDenyBucketKeyRequest struct {
	ctx context.Context
	ApiService *BucketApiService
	allowBucketKeyRequest *AllowBucketKeyRequest
}

// Aliases to put on the new bucket 
func (r ApiDenyBucketKeyRequest) AllowBucketKeyRequest(allowBucketKeyRequest AllowBucketKeyRequest) ApiDenyBucketKeyRequest {
	r.allowBucketKeyRequest = &allowBucketKeyRequest
	return r
}

func (r ApiDenyBucketKeyRequest) Execute() (*BucketInfo, *http.Response, error) {
	return r.ApiService.DenyBucketKeyExecute(r)
}

/*
DenyBucketKey Deny key

⚠️ **DISCLAIMER**: Garage's developers are aware that this endpoint has an unconventional semantic. Be extra careful when implementing it, its behavior is not obvious.

Denies a key from doing read/write/owner operations on a bucket.

Flags in permissions which have the value true will be deactivated. Other flags will remain unchanged.

For example, if you set read to true, the key will be denied from reading.
If you set read to false,  the key will keep its previous permissions.
If you want the key to have the reading permission, check the AllowBucketKey operation.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDenyBucketKeyRequest
*/
func (a *BucketApiService) DenyBucketKey(ctx context.Context) ApiDenyBucketKeyRequest {
	return ApiDenyBucketKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BucketInfo
func (a *BucketApiService) DenyBucketKeyExecute(r ApiDenyBucketKeyRequest) (*BucketInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BucketInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketApiService.DenyBucketKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucket/deny"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.allowBucketKeyRequest == nil {
		return localVarReturnValue, nil, reportError("allowBucketKeyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.allowBucketKeyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBucketInfoRequest struct {
	ctx context.Context
	ApiService *BucketApiService
	id *string
	alias *string
}

// The exact bucket identifier, a 32 bytes hexadecimal string.  Incompatible with &#x60;alias&#x60;. 
func (r ApiGetBucketInfoRequest) Id(id string) ApiGetBucketInfoRequest {
	r.id = &id
	return r
}

// The exact global alias of one of the existing buckets.  Incompatible with &#x60;id&#x60;. 
func (r ApiGetBucketInfoRequest) Alias(alias string) ApiGetBucketInfoRequest {
	r.alias = &alias
	return r
}

func (r ApiGetBucketInfoRequest) Execute() (*BucketInfo, *http.Response, error) {
	return r.ApiService.GetBucketInfoExecute(r)
}

/*
GetBucketInfo Get a bucket

Given a bucket identifier (`id`) or a global alias (`alias`), get its information.
It includes its aliases, its web configuration, keys that have some permissions
on it, some statistics (number of objects, size), number of dangling multipart uploads,
and its quotas (if any).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBucketInfoRequest
*/
func (a *BucketApiService) GetBucketInfo(ctx context.Context) ApiGetBucketInfoRequest {
	return ApiGetBucketInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BucketInfo
func (a *BucketApiService) GetBucketInfoExecute(r ApiGetBucketInfoRequest) (*BucketInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BucketInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketApiService.GetBucketInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.alias != nil {
		localVarQueryParams.Add("alias", parameterToString(*r.alias, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBucketsRequest struct {
	ctx context.Context
	ApiService *BucketApiService
}

func (r ApiListBucketsRequest) Execute() ([]ListBuckets200ResponseInner, *http.Response, error) {
	return r.ApiService.ListBucketsExecute(r)
}

/*
ListBuckets List all buckets

List all the buckets on the cluster with their UUID and their global and local aliases.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBucketsRequest
*/
func (a *BucketApiService) ListBuckets(ctx context.Context) ApiListBucketsRequest {
	return ApiListBucketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListBuckets200ResponseInner
func (a *BucketApiService) ListBucketsExecute(r ApiListBucketsRequest) ([]ListBuckets200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListBuckets200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketApiService.ListBuckets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucket?list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutBucketGlobalAliasRequest struct {
	ctx context.Context
	ApiService *BucketApiService
	id *string
	alias *string
}

func (r ApiPutBucketGlobalAliasRequest) Id(id string) ApiPutBucketGlobalAliasRequest {
	r.id = &id
	return r
}

func (r ApiPutBucketGlobalAliasRequest) Alias(alias string) ApiPutBucketGlobalAliasRequest {
	r.alias = &alias
	return r
}

func (r ApiPutBucketGlobalAliasRequest) Execute() (*BucketInfo, *http.Response, error) {
	return r.ApiService.PutBucketGlobalAliasExecute(r)
}

/*
PutBucketGlobalAlias Add a global alias

Add a global alias to the target bucket


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutBucketGlobalAliasRequest
*/
func (a *BucketApiService) PutBucketGlobalAlias(ctx context.Context) ApiPutBucketGlobalAliasRequest {
	return ApiPutBucketGlobalAliasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BucketInfo
func (a *BucketApiService) PutBucketGlobalAliasExecute(r ApiPutBucketGlobalAliasRequest) (*BucketInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BucketInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketApiService.PutBucketGlobalAlias")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucket/alias/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.alias == nil {
		return localVarReturnValue, nil, reportError("alias is required and must be specified")
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	localVarQueryParams.Add("alias", parameterToString(*r.alias, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutBucketLocalAliasRequest struct {
	ctx context.Context
	ApiService *BucketApiService
	id *string
	accessKeyId *string
	alias *string
}

func (r ApiPutBucketLocalAliasRequest) Id(id string) ApiPutBucketLocalAliasRequest {
	r.id = &id
	return r
}

func (r ApiPutBucketLocalAliasRequest) AccessKeyId(accessKeyId string) ApiPutBucketLocalAliasRequest {
	r.accessKeyId = &accessKeyId
	return r
}

func (r ApiPutBucketLocalAliasRequest) Alias(alias string) ApiPutBucketLocalAliasRequest {
	r.alias = &alias
	return r
}

func (r ApiPutBucketLocalAliasRequest) Execute() (*BucketInfo, *http.Response, error) {
	return r.ApiService.PutBucketLocalAliasExecute(r)
}

/*
PutBucketLocalAlias Add a local alias

Add a local alias, bound to specified account, to the target bucket


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutBucketLocalAliasRequest
*/
func (a *BucketApiService) PutBucketLocalAlias(ctx context.Context) ApiPutBucketLocalAliasRequest {
	return ApiPutBucketLocalAliasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BucketInfo
func (a *BucketApiService) PutBucketLocalAliasExecute(r ApiPutBucketLocalAliasRequest) (*BucketInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BucketInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketApiService.PutBucketLocalAlias")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucket/alias/local"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.accessKeyId == nil {
		return localVarReturnValue, nil, reportError("accessKeyId is required and must be specified")
	}
	if r.alias == nil {
		return localVarReturnValue, nil, reportError("alias is required and must be specified")
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	localVarQueryParams.Add("accessKeyId", parameterToString(*r.accessKeyId, ""))
	localVarQueryParams.Add("alias", parameterToString(*r.alias, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBucketRequest struct {
	ctx context.Context
	ApiService *BucketApiService
	id *string
	updateBucketRequest *UpdateBucketRequest
}

// The exact bucket identifier, a 32 bytes hexadecimal string
func (r ApiUpdateBucketRequest) Id(id string) ApiUpdateBucketRequest {
	r.id = &id
	return r
}

// Requested changes on the bucket. Both root fields are optionals. 
func (r ApiUpdateBucketRequest) UpdateBucketRequest(updateBucketRequest UpdateBucketRequest) ApiUpdateBucketRequest {
	r.updateBucketRequest = &updateBucketRequest
	return r
}

func (r ApiUpdateBucketRequest) Execute() (*BucketInfo, *http.Response, error) {
	return r.ApiService.UpdateBucketExecute(r)
}

/*
UpdateBucket Update a bucket

All fields (`websiteAccess` and `quotas`) are optional.
If they are present, the corresponding modifications are applied to the bucket, otherwise nothing is changed.

In `websiteAccess`: if `enabled` is `true`, `indexDocument` must be specified.
The field `errorDocument` is optional, if no error document is set a generic
error message is displayed when errors happen. Conversely, if `enabled` is
`false`, neither `indexDocument` nor `errorDocument` must be specified.

In `quotas`: new values of `maxSize` and `maxObjects` must both be specified, or set to `null`
to remove the quotas. An absent value will be considered the same as a `null`. It is not possible
to change only one of the two quotas.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateBucketRequest
*/
func (a *BucketApiService) UpdateBucket(ctx context.Context) ApiUpdateBucketRequest {
	return ApiUpdateBucketRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BucketInfo
func (a *BucketApiService) UpdateBucketExecute(r ApiUpdateBucketRequest) (*BucketInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BucketInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BucketApiService.UpdateBucket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bucket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.updateBucketRequest == nil {
		return localVarReturnValue, nil, reportError("updateBucketRequest is required and must be specified")
	}

	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateBucketRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
